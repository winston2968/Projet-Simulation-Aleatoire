# ==========================================================================================
#                                 Nuclear Reactor Simulation
# ==========================================================================================

from matplotlib import pyplot as plt
import numpy as np 
from numpy import random as npr
from rich.live import Live
from rich.table import Table
from time import sleep

import random_process


# ----------------------------
# Simulate a simple nuclear reactor
# ----------------------------
# Inputs:
#     - n, m : size of the grid (n rows x m columns)
#     - state : dictionary containing neutrons positions {id: (x,y)}
#     - d : diffusion probability
#     - a : absorption probability
#     - f : fission probability
#     - l : parameter controlling number of new neutrons generated during fission
#     - n_iter : number of iterations to simulate
# Behavior:
#     - Iteratively updates neutron positions based on diffusion, absorption, and fission
#     - Adds new neutrons generated by fission
#     - Updates the display in real-time using Rich Live
def simul_reactor(n, m, state, d, a, f, l, n_iter):
    with Live(make_table(build_grid(n, m, state)), refresh_per_second=10) as live:
        for _ in range(n_iter):
            new_state = {}
            all_new_neutrons = {}
            for i, pos in state.items():
                new_pos, new_neutrons = random_process.new_position(state, pos, d, a, f, l, n, m)

                if new_pos is False:
                    continue
                elif is_in_the_grid(new_pos[0], new_pos[1], n, m):
                    new_state[i] = new_pos

                all_new_neutrons.update(new_neutrons)

            # Add new neutrons generated by fission
            new_state.update(all_new_neutrons)
            state = new_state

            # Update the display
            grid = build_grid(n, m, state)
            live.update(make_table(grid))
            sleep(0.2)


# ----------------------------
# Check if a position is within the grid
# ----------------------------
# Inputs:
#     - x, y : coordinates to check
#     - n, m : size of the grid
# Returns:
#     - True if the position is inside the grid, False otherwise
def is_in_the_grid(x, y, n, m): 
    return 0 <= x < n and 0 <= y < m


# ----------------------------
# Build the grid for visualization
# ----------------------------
# Inputs:
#     - n, m : size of the grid
#     - state : dictionary containing neutron positions {id: (x,y)}
# Returns:
#     - grid : 2D array (list of lists) representing the current neutron positions
def build_grid(n, m, state): 
    grid = [[0 for _ in range(m)] for _ in range(n)]
    for neutron, (x, y) in state.items(): 
        grid[x][y] += 1
    return grid 


# ----------------------------
# Convert the grid into a Rich Table for display
# ----------------------------
# Inputs:
#     - grid : 2D array representing the neutron positions
# Returns:
#     - Rich Table object ready for display in the terminal
def make_table(grid):
    table = Table(show_header=False, show_lines=True)
    for line in grid:
        table.add_row(*[str(x) if x > 0 else ' ' for x in line])
    return table


# ----------------------------
# Main execution
# ----------------------------
n = 20
if __name__ == "__main__":
    # Initialize 10 neutrons at the center of a 10x10 grid
    state = {i: (n//2, n//2) for i in range(n)}
    simul_reactor(n, n, state, d=0.2, a=0.1, f=0.7, l=1000, n_iter=70)
