# ==========================================================================================
#                                 Nuclear Reactor Class
# ==========================================================================================

from matplotlib import pyplot as plt
import numpy as np 
from numpy import random as npr
from rich.live import Live
from rich.table import Table
from time import sleep

from utils import simul_poisson

class Reactor: 

    def __init__(self, live, config):
        self.n = config['n'] 
        self.m = config['m']
        self.n_initial = config['n_initial']
        self.d = config['d']
        self.a = config['a']
        self.f = config['f']
        self.l = config['l']
        self.n_iter = config['n_iter'] 
        self.max_speed = config['max_speed']
        self.state = {i: (self.n // 2 + 1 , self.m // 2 + 1) for i in range(self.n_initial)} 
        self.grid = 0
        self.live = live
        self.toric = config['toric']
        self.history = [self.state]
        self.display = config['display']

    # Choose which action to perform for a neutron at each iteration
    # Inputs: 
    #     - d : diffusion probability
    #     - a : absorption probability
    #     - f : fission probability
    # Returns:
    #     - 0 for diffusion, 1 for absorption, 2 for fission
    def choose_action(self): 
        total = self.d + self.a + self.f
        d1, a1 = self.d/total, self.a/total
        u = npr.rand()
        l = [d1, d1+a1, 1.0]
        x = 0
        while u > l[x]:
            x += 1
        return x
    
    # Generate a new direction for diffusion
    # Returns:
    #     - dx, dy : integers in [-1, 0, 1] representing the change in x and y
    #     - ensures that dx and dy are not both zero (the neutron moves)
    def choose_direction(self): 
        while True :
            dx, dy = npr.choice([-1, 0, 1]), npr.choice([-1, 0, 1])
            if dx != 0 or dy != 0 :
                return dx, dy

    # Compute the new position of a neutron based on its current state and action probabilities
    # Inputs:
    #     - state : dictionary containing current neutrons {id: (x,y)}
    #     - pos : tuple (x,y) representing the current position of the neutron
    #     - d, a, f : probabilities for diffusion, absorption, and fission
    #     - l : parameter for Poisson distribution in fission
    #     - n, m : size of the grid
    #     - max_speed : maximum number of cells the neutron can move during diffusion
    # Returns:
    #     - new_pos : tuple (new_x, new_y) or (False, False) if absorbed
    #     - new_neutrons : dictionary of newly created neutrons during fission {id: (x,y)}
    def new_position(self, pos, next_id_counter): 
        x, y = pos
        action = self.choose_action()
        new_pos = (x, y)
        new_neutrons = {}

        # Diffusion
        if action == 0:
            dx, dy = self.choose_direction()
            step_x = dx * npr.randint(1, self.max_speed+1)
            step_y = dy * npr.randint(1, self.max_speed+1)
            new_x = x + step_x
            new_y = y + step_y
            new_pos = (new_x, new_y)

        # Absorption
        elif action == 1:
            new_pos = False

        # Fission
        elif action == 2:
            n_new = simul_poisson(self.l)
            for _ in range(n_new):
                dx, dy = (npr.choice([-1,1]), npr.choice([-1,1]))
                nx = x + dx 
                ny = y + dy 
                if self.is_in_the_grid(nx, ny): 
                    new_neutrons[next_id_counter] = (nx, ny)
                next_id_counter += 1

        return new_pos, new_neutrons, next_id_counter


    # -----------------------------------------
    # Check if a position is within the grid
    # -----------------------------------------
    # Inputs:
    #     - x, y : coordinates to check
    #     - n, m : size of the grid
    # Returns:
    #     - True if the position is inside the grid, False otherwise
    def is_in_the_grid(self, i, j): 
        return 0 <= i < self.n and 0 <= j < self.m

    # --------------------------------------
    # Simulate a simple nuclear reactor
    # --------------------------------------
    # Inputs:
    #     - n, m : size of the grid (n rows x m columns)
    #     - state : dictionary containing neutrons positions {id: (x,y)}
    #     - d : diffusion probability
    #     - a : absorption probability
    #     - f : fission probability
    #     - l : parameter controlling number of new neutrons generated during fission
    #     - n_iter : number of iterations to simulate
    # Behavior:
    #     - Iteratively updates neutron positions based on diffusion, absorption, and fission
    #     - Adds new neutrons generated by fission
    #     - Updates the display in real-time using Rich Live
    def simulate(self): 
        next_id_counter = max(self.state.keys()) + 1
        for _ in range(self.n_iter):
            new_state = {}
            for neutron, pos in self.state.items():
                new_pos, new_neutrons, next_id_counter = self.new_position(pos, next_id_counter)

                if new_pos is False:  # AbsorbÃ©
                    continue

                x, y = new_pos
                if self.toric:
                    x %= self.n
                    y %= self.m
                    new_state[neutron] = (x, y)
                
                elif self.is_in_the_grid(x, y):
                    new_state[neutron] = (x, y)

                new_state.update(new_neutrons)

            self.state = new_state
            self.history.append(self.state)
            if self.display :
                self.display_reactor()
        return self.history

    # ----------------------------------
    # Build the grid for visualization
    # ----------------------------------
    # Inputs:
    #     - n, m : size of the grid
    #     - state : dictionary containing neutron positions {id: (x,y)}
    # Returns:
    #     - grid : 2D array (list of lists) representing the current neutron positions
    def build_grid(self):
        grid = [[0 for _ in range(self.m)] for _ in range(self.n)]
        for neutron, (x, y) in self.state.items():
            grid[x][y] += 1
        self.grid = grid 
    
    def display_reactor(self):
        # Build grid 
        self.build_grid()
        # Create the corresponding table 
        table = Table(show_header=False, show_lines=True)
        for line in self.grid:
            table.add_row(*[str(x) if x > 0 else ' ' for x in line])
        self.live.update(table)
        sleep(0.2)
